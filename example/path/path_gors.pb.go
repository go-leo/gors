// Code generated by protoc-gen-gors. DO NOT EDIT.

package path

import (
	context "context"
	fmt "fmt"
	v2 "github.com/go-leo/gors/v2"
	urlx "github.com/go-leo/gox/netx/urlx"
	mux "github.com/gorilla/mux"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	http "net/http"
)

type BoolPathGorsService interface {
	BoolPath(ctx context.Context, request *BoolPathRequest) (*emptypb.Empty, error)
}

func AppendBoolPathGorsRoute(router *mux.Router, service BoolPathGorsService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := boolPathGorsHandler{
		service: service,
		decoder: boolPathGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: boolPathGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.example.path.v1.BoolPath/BoolPath").
		Methods("GET").
		Path("/v1/{bool}/{opt_bool}/{wrap_bool}").
		Handler(handler.BoolPath())
	return router
}

type boolPathGorsHandler struct {
	service      BoolPathGorsService
	decoder      boolPathGorsRequestDecoder
	encoder      boolPathGorsResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h boolPathGorsHandler) BoolPath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.BoolPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.BoolPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.BoolPath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type boolPathGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder boolPathGorsRequestDecoder) BoolPath(ctx context.Context, r *http.Request) (*BoolPathRequest, error) {
	req := &BoolPathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Bool, varErr = v2.FormDecoder[bool](varErr, vars, "bool", urlx.GetBool)
	req.OptBool, varErr = v2.FormDecoder[*bool](varErr, vars, "opt_bool", urlx.GetBoolPtr)
	req.WrapBool, varErr = v2.FormDecoder[*wrapperspb.BoolValue](varErr, vars, "wrap_bool", urlx.GetBoolValue)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type boolPathGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder boolPathGorsResponseEncoder) BoolPath(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type Int32PathGorsService interface {
	Int32Path(ctx context.Context, request *Int32PathRequest) (*emptypb.Empty, error)
}

func AppendInt32PathGorsRoute(router *mux.Router, service Int32PathGorsService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := int32PathGorsHandler{
		service: service,
		decoder: int32PathGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int32PathGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.example.path.v1.Int32Path/Int32Path").
		Methods("GET").
		Path("/v1/{int32}/{sint32}/{sfixed32}/{opt_int32}/{opt_sint32}/{opt_sfixed32}/{wrap_int32}").
		Handler(handler.Int32Path())
	return router
}

type int32PathGorsHandler struct {
	service      Int32PathGorsService
	decoder      int32PathGorsRequestDecoder
	encoder      int32PathGorsResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h int32PathGorsHandler) Int32Path() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Int32Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Int32Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Int32Path(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type int32PathGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int32PathGorsRequestDecoder) Int32Path(ctx context.Context, r *http.Request) (*Int32PathRequest, error) {
	req := &Int32PathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Int32, varErr = v2.FormDecoder[int32](varErr, vars, "int32", urlx.GetInt)
	req.Sint32, varErr = v2.FormDecoder[int32](varErr, vars, "sint32", urlx.GetInt)
	req.Sfixed32, varErr = v2.FormDecoder[int32](varErr, vars, "sfixed32", urlx.GetInt)
	req.OptInt32, varErr = v2.FormDecoder[*int32](varErr, vars, "opt_int32", urlx.GetIntPtr)
	req.OptSint32, varErr = v2.FormDecoder[*int32](varErr, vars, "opt_sint32", urlx.GetIntPtr)
	req.OptSfixed32, varErr = v2.FormDecoder[*int32](varErr, vars, "opt_sfixed32", urlx.GetIntPtr)
	req.WrapInt32, varErr = v2.FormDecoder[*wrapperspb.Int32Value](varErr, vars, "wrap_int32", urlx.GetInt32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type int32PathGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder int32PathGorsResponseEncoder) Int32Path(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type Int64PathGorsService interface {
	Int64Path(ctx context.Context, request *Int64PathRequest) (*emptypb.Empty, error)
}

func AppendInt64PathGorsRoute(router *mux.Router, service Int64PathGorsService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := int64PathGorsHandler{
		service: service,
		decoder: int64PathGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int64PathGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.example.path.v1.Int64Path/Int64Path").
		Methods("GET").
		Path("/v1/{int64}/{sint64}/{sfixed64}/{opt_int64}/{opt_sint64}/{opt_sfixed64}/{wrap_int64}").
		Handler(handler.Int64Path())
	return router
}

type int64PathGorsHandler struct {
	service      Int64PathGorsService
	decoder      int64PathGorsRequestDecoder
	encoder      int64PathGorsResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h int64PathGorsHandler) Int64Path() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Int64Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Int64Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Int64Path(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type int64PathGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int64PathGorsRequestDecoder) Int64Path(ctx context.Context, r *http.Request) (*Int64PathRequest, error) {
	req := &Int64PathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Int64, varErr = v2.FormDecoder[int64](varErr, vars, "int64", urlx.GetInt)
	req.Sint64, varErr = v2.FormDecoder[int64](varErr, vars, "sint64", urlx.GetInt)
	req.Sfixed64, varErr = v2.FormDecoder[int64](varErr, vars, "sfixed64", urlx.GetInt)
	req.OptInt64, varErr = v2.FormDecoder[*int64](varErr, vars, "opt_int64", urlx.GetIntPtr)
	req.OptSint64, varErr = v2.FormDecoder[*int64](varErr, vars, "opt_sint64", urlx.GetIntPtr)
	req.OptSfixed64, varErr = v2.FormDecoder[*int64](varErr, vars, "opt_sfixed64", urlx.GetIntPtr)
	req.WrapInt64, varErr = v2.FormDecoder[*wrapperspb.Int64Value](varErr, vars, "wrap_int64", urlx.GetInt64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type int64PathGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder int64PathGorsResponseEncoder) Int64Path(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type Uint32PathGorsService interface {
	Uint32Path(ctx context.Context, request *Uint32PathRequest) (*emptypb.Empty, error)
}

func AppendUint32PathGorsRoute(router *mux.Router, service Uint32PathGorsService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := uint32PathGorsHandler{
		service: service,
		decoder: uint32PathGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint32PathGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.example.path.v1.Uint32Path/Uint32Path").
		Methods("GET").
		Path("/v1/{uint32}/{fixed32}/{opt_uint32}/{opt_fixed32}/{wrap_uint32}").
		Handler(handler.Uint32Path())
	return router
}

type uint32PathGorsHandler struct {
	service      Uint32PathGorsService
	decoder      uint32PathGorsRequestDecoder
	encoder      uint32PathGorsResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h uint32PathGorsHandler) Uint32Path() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Uint32Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Uint32Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Uint32Path(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type uint32PathGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint32PathGorsRequestDecoder) Uint32Path(ctx context.Context, r *http.Request) (*Uint32PathRequest, error) {
	req := &Uint32PathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Uint32, varErr = v2.FormDecoder[uint32](varErr, vars, "uint32", urlx.GetUint)
	req.Fixed32, varErr = v2.FormDecoder[uint32](varErr, vars, "fixed32", urlx.GetUint)
	req.OptUint32, varErr = v2.FormDecoder[*uint32](varErr, vars, "opt_uint32", urlx.GetUintPtr)
	req.OptFixed32, varErr = v2.FormDecoder[*uint32](varErr, vars, "opt_fixed32", urlx.GetUintPtr)
	req.WrapUint32, varErr = v2.FormDecoder[*wrapperspb.UInt32Value](varErr, vars, "wrap_uint32", urlx.GetUint32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type uint32PathGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder uint32PathGorsResponseEncoder) Uint32Path(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type Uint64PathGorsService interface {
	Uint64Path(ctx context.Context, request *Uint64PathRequest) (*emptypb.Empty, error)
}

func AppendUint64PathGorsRoute(router *mux.Router, service Uint64PathGorsService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := uint64PathGorsHandler{
		service: service,
		decoder: uint64PathGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint64PathGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.example.path.v1.Uint64Path/Uint64Path").
		Methods("GET").
		Path("/v1/{uint64}/{fixed64}/{opt_uint64}/{opt_fixed64}/{wrap_uint64}").
		Handler(handler.Uint64Path())
	return router
}

type uint64PathGorsHandler struct {
	service      Uint64PathGorsService
	decoder      uint64PathGorsRequestDecoder
	encoder      uint64PathGorsResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h uint64PathGorsHandler) Uint64Path() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.Uint64Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.Uint64Path(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.Uint64Path(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type uint64PathGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint64PathGorsRequestDecoder) Uint64Path(ctx context.Context, r *http.Request) (*Uint64PathRequest, error) {
	req := &Uint64PathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Uint64, varErr = v2.FormDecoder[uint64](varErr, vars, "uint64", urlx.GetUint)
	req.Fixed64, varErr = v2.FormDecoder[uint64](varErr, vars, "fixed64", urlx.GetUint)
	req.OptUint64, varErr = v2.FormDecoder[*uint64](varErr, vars, "opt_uint64", urlx.GetUintPtr)
	req.OptFixed64, varErr = v2.FormDecoder[*uint64](varErr, vars, "opt_fixed64", urlx.GetUintPtr)
	req.WrapUint64, varErr = v2.FormDecoder[*wrapperspb.UInt64Value](varErr, vars, "wrap_uint64", urlx.GetUint64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type uint64PathGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder uint64PathGorsResponseEncoder) Uint64Path(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type FloatPathGorsService interface {
	FloatPath(ctx context.Context, request *FloatPathRequest) (*emptypb.Empty, error)
}

func AppendFloatPathGorsRoute(router *mux.Router, service FloatPathGorsService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := floatPathGorsHandler{
		service: service,
		decoder: floatPathGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: floatPathGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.example.path.v1.FloatPath/FloatPath").
		Methods("GET").
		Path("/v1/{float}/{opt_float}/{wrap_float}").
		Handler(handler.FloatPath())
	return router
}

type floatPathGorsHandler struct {
	service      FloatPathGorsService
	decoder      floatPathGorsRequestDecoder
	encoder      floatPathGorsResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h floatPathGorsHandler) FloatPath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.FloatPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.FloatPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.FloatPath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type floatPathGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder floatPathGorsRequestDecoder) FloatPath(ctx context.Context, r *http.Request) (*FloatPathRequest, error) {
	req := &FloatPathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Float, varErr = v2.FormDecoder[float32](varErr, vars, "float", urlx.GetFloat)
	req.OptFloat, varErr = v2.FormDecoder[*float32](varErr, vars, "opt_float", urlx.GetFloatPtr)
	req.WrapFloat, varErr = v2.FormDecoder[*wrapperspb.FloatValue](varErr, vars, "wrap_float", urlx.GetFloat32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type floatPathGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder floatPathGorsResponseEncoder) FloatPath(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type DoublePathGorsService interface {
	DoublePath(ctx context.Context, request *DoublePathRequest) (*emptypb.Empty, error)
}

func AppendDoublePathGorsRoute(router *mux.Router, service DoublePathGorsService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := doublePathGorsHandler{
		service: service,
		decoder: doublePathGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: doublePathGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.example.path.v1.DoublePath/DoublePath").
		Methods("GET").
		Path("/v1/{double}/{opt_double}/{wrap_double}").
		Handler(handler.DoublePath())
	return router
}

type doublePathGorsHandler struct {
	service      DoublePathGorsService
	decoder      doublePathGorsRequestDecoder
	encoder      doublePathGorsResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h doublePathGorsHandler) DoublePath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.DoublePath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.DoublePath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.DoublePath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type doublePathGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder doublePathGorsRequestDecoder) DoublePath(ctx context.Context, r *http.Request) (*DoublePathRequest, error) {
	req := &DoublePathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Double, varErr = v2.FormDecoder[float64](varErr, vars, "double", urlx.GetFloat)
	req.OptDouble, varErr = v2.FormDecoder[*float64](varErr, vars, "opt_double", urlx.GetFloatPtr)
	req.WrapDouble, varErr = v2.FormDecoder[*wrapperspb.DoubleValue](varErr, vars, "wrap_double", urlx.GetFloat64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type doublePathGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder doublePathGorsResponseEncoder) DoublePath(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type StringPathGorsService interface {
	StringPath(ctx context.Context, request *StringPathRequest) (*emptypb.Empty, error)
}

func AppendStringPathGorsRoute(router *mux.Router, service StringPathGorsService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := stringPathGorsHandler{
		service: service,
		decoder: stringPathGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: stringPathGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.example.path.v1.StringPath/StringPath").
		Methods("GET").
		Path("/v1/{string}/{opt_string}/{wrap_string}").
		Handler(handler.StringPath())
	return router
}

type stringPathGorsHandler struct {
	service      StringPathGorsService
	decoder      stringPathGorsRequestDecoder
	encoder      stringPathGorsResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h stringPathGorsHandler) StringPath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.StringPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.StringPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.StringPath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type stringPathGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder stringPathGorsRequestDecoder) StringPath(ctx context.Context, r *http.Request) (*StringPathRequest, error) {
	req := &StringPathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.String_ = vars.Get("string")
	req.OptString = proto.String(vars.Get("opt_string"))
	req.WrapString = wrapperspb.String(vars.Get("wrap_string"))
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type stringPathGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder stringPathGorsResponseEncoder) StringPath(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type EnumPathGorsService interface {
	EnumPath(ctx context.Context, request *EnumPathRequest) (*emptypb.Empty, error)
}

func AppendEnumPathGorsRoute(router *mux.Router, service EnumPathGorsService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := enumPathGorsHandler{
		service: service,
		decoder: enumPathGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: enumPathGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.example.path.v1.EnumPath/EnumPath").
		Methods("GET").
		Path("/v1/{status}/{opt_status}").
		Handler(handler.EnumPath())
	return router
}

type enumPathGorsHandler struct {
	service      EnumPathGorsService
	decoder      enumPathGorsRequestDecoder
	encoder      enumPathGorsResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h enumPathGorsHandler) EnumPath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.EnumPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.EnumPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.EnumPath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type enumPathGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder enumPathGorsRequestDecoder) EnumPath(ctx context.Context, r *http.Request) (*EnumPathRequest, error) {
	req := &EnumPathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Status, varErr = v2.FormDecoder[EnumPathRequest_Status](varErr, vars, "status", urlx.GetInt[EnumPathRequest_Status])
	req.OptStatus, varErr = v2.FormDecoder[*EnumPathRequest_Status](varErr, vars, "opt_status", urlx.GetIntPtr[EnumPathRequest_Status])
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type enumPathGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder enumPathGorsResponseEncoder) EnumPath(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type NamedPathGorsService interface {
	NamedPathString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error)
	NamedPathOptString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error)
	NamedPathWrapString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error)
	EmbedNamedPathString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error)
	EmbedNamedPathOptString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error)
	EmbedNamedPathWrapString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error)
}

func AppendNamedPathGorsRoute(router *mux.Router, service NamedPathGorsService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := namedPathGorsHandler{
		service: service,
		decoder: namedPathGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: namedPathGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.example.path.v1.NamedPath/NamedPathString").
		Methods("GET").
		Path("/v1/string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}").
		Handler(handler.NamedPathString())
	router.NewRoute().
		Name("/leo.gors.example.path.v1.NamedPath/NamedPathOptString").
		Methods("GET").
		Path("/v1/opt_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}").
		Handler(handler.NamedPathOptString())
	router.NewRoute().
		Name("/leo.gors.example.path.v1.NamedPath/NamedPathWrapString").
		Methods("GET").
		Path("/v1/wrap_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}").
		Handler(handler.NamedPathWrapString())
	router.NewRoute().
		Name("/leo.gors.example.path.v1.NamedPath/EmbedNamedPathString").
		Methods("GET").
		Path("/v1/embed/string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}").
		Handler(handler.EmbedNamedPathString())
	router.NewRoute().
		Name("/leo.gors.example.path.v1.NamedPath/EmbedNamedPathOptString").
		Methods("GET").
		Path("/v1/embed/opt_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}").
		Handler(handler.EmbedNamedPathOptString())
	router.NewRoute().
		Name("/leo.gors.example.path.v1.NamedPath/EmbedNamedPathWrapString").
		Methods("GET").
		Path("/v1/embed/wrap_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}").
		Handler(handler.EmbedNamedPathWrapString())
	return router
}

type namedPathGorsHandler struct {
	service      NamedPathGorsService
	decoder      namedPathGorsRequestDecoder
	encoder      namedPathGorsResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h namedPathGorsHandler) NamedPathString() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.NamedPathString(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.NamedPathString(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.NamedPathString(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

func (h namedPathGorsHandler) NamedPathOptString() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.NamedPathOptString(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.NamedPathOptString(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.NamedPathOptString(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

func (h namedPathGorsHandler) NamedPathWrapString() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.NamedPathWrapString(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.NamedPathWrapString(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.NamedPathWrapString(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

func (h namedPathGorsHandler) EmbedNamedPathString() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.EmbedNamedPathString(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.EmbedNamedPathString(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.EmbedNamedPathString(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

func (h namedPathGorsHandler) EmbedNamedPathOptString() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.EmbedNamedPathOptString(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.EmbedNamedPathOptString(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.EmbedNamedPathOptString(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

func (h namedPathGorsHandler) EmbedNamedPathWrapString() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.EmbedNamedPathWrapString(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.EmbedNamedPathWrapString(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.EmbedNamedPathWrapString(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type namedPathGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder namedPathGorsRequestDecoder) NamedPathString(ctx context.Context, r *http.Request) (*NamedPathRequest, error) {
	req := &NamedPathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	req.String_ = fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars.Get("class"), vars.Get("shelf"), vars.Get("book"), vars.Get("family"))
	queries := r.URL.Query()
	var queryErr error
	req.OptString = proto.String(queries.Get("opt_string"))
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}
func (decoder namedPathGorsRequestDecoder) NamedPathOptString(ctx context.Context, r *http.Request) (*NamedPathRequest, error) {
	req := &NamedPathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	req.OptString = proto.String(fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars.Get("class"), vars.Get("shelf"), vars.Get("book"), vars.Get("family")))
	queries := r.URL.Query()
	var queryErr error
	req.String_ = queries.Get("string")
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}
func (decoder namedPathGorsRequestDecoder) NamedPathWrapString(ctx context.Context, r *http.Request) (*NamedPathRequest, error) {
	req := &NamedPathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	req.WrapString = wrapperspb.String(fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars.Get("class"), vars.Get("shelf"), vars.Get("book"), vars.Get("family")))
	queries := r.URL.Query()
	var queryErr error
	req.String_ = queries.Get("string")
	req.OptString = proto.String(queries.Get("opt_string"))
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}
func (decoder namedPathGorsRequestDecoder) EmbedNamedPathString(ctx context.Context, r *http.Request) (*EmbedNamedPathRequest, error) {
	req := &EmbedNamedPathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	if req.Embed == nil {
		req.Embed = &NamedPathRequest{}
	}
	req.Embed.String_ = fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars.Get("class"), vars.Get("shelf"), vars.Get("book"), vars.Get("family"))
	return req, nil
}
func (decoder namedPathGorsRequestDecoder) EmbedNamedPathOptString(ctx context.Context, r *http.Request) (*EmbedNamedPathRequest, error) {
	req := &EmbedNamedPathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	if req.Embed == nil {
		req.Embed = &NamedPathRequest{}
	}
	req.Embed.OptString = proto.String(fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars.Get("class"), vars.Get("shelf"), vars.Get("book"), vars.Get("family")))
	return req, nil
}
func (decoder namedPathGorsRequestDecoder) EmbedNamedPathWrapString(ctx context.Context, r *http.Request) (*EmbedNamedPathRequest, error) {
	req := &EmbedNamedPathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	if req.Embed == nil {
		req.Embed = &NamedPathRequest{}
	}
	req.Embed.WrapString = wrapperspb.String(fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars.Get("class"), vars.Get("shelf"), vars.Get("book"), vars.Get("family")))
	return req, nil
}

type namedPathGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder namedPathGorsResponseEncoder) NamedPathString(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}
func (encoder namedPathGorsResponseEncoder) NamedPathOptString(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}
func (encoder namedPathGorsResponseEncoder) NamedPathWrapString(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}
func (encoder namedPathGorsResponseEncoder) EmbedNamedPathString(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}
func (encoder namedPathGorsResponseEncoder) EmbedNamedPathOptString(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}
func (encoder namedPathGorsResponseEncoder) EmbedNamedPathWrapString(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}

type MixPathGorsService interface {
	MixPath(ctx context.Context, request *MixPathRequest) (*emptypb.Empty, error)
}

func AppendMixPathGorsRoute(router *mux.Router, service MixPathGorsService, opts ...v2.Option) *mux.Router {
	options := v2.NewOptions(opts...)
	handler := mixPathGorsHandler{
		service: service,
		decoder: mixPathGorsRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: mixPathGorsResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder: v2.DefaultErrorEncoder,
	}
	router.NewRoute().
		Name("/leo.gors.example.path.v1.MixPath/MixPath").
		Methods("GET").
		Path("/v1/{string}/{opt_string}/{wrap_string}/classes/{class}/shelves/{shelf}/books/{book}/families/{family}").
		Handler(handler.MixPath())
	return router
}

type mixPathGorsHandler struct {
	service      MixPathGorsService
	decoder      mixPathGorsRequestDecoder
	encoder      mixPathGorsResponseEncoder
	errorEncoder v2.ErrorEncoder
}

func (h mixPathGorsHandler) MixPath() http.Handler {
	return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		in, err := h.decoder.MixPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		out, err := h.service.MixPath(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
		if err := h.encoder.MixPath(ctx, writer, out); err != nil {
			h.errorEncoder(ctx, err, writer)
			return
		}
	})
}

type mixPathGorsRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder mixPathGorsRequestDecoder) MixPath(ctx context.Context, r *http.Request) (*MixPathRequest, error) {
	req := &MixPathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	if req.Embed == nil {
		req.Embed = &NamedPathRequest{}
	}
	req.Embed.WrapString = wrapperspb.String(fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars.Get("class"), vars.Get("shelf"), vars.Get("book"), vars.Get("family")))
	var varErr error
	req.String_ = vars.Get("string")
	req.OptString = proto.String(vars.Get("opt_string"))
	req.WrapString = wrapperspb.String(vars.Get("wrap_string"))
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type mixPathGorsResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer v2.ResponseTransformer
}

func (encoder mixPathGorsResponseEncoder) MixPath(ctx context.Context, w http.ResponseWriter, resp *emptypb.Empty) error {
	return v2.ResponseEncoder(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
}
